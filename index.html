<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM PARTICLE TERMINAL v1.0</title>
    <style>
        body { margin: 0; background: #050505; color: #00f2ff; font-family: 'Courier New', Courier, monospace; overflow: hidden; text-transform: uppercase; }
        canvas { display: block; }

        /* HUD Styling - Quant Sci-Fi */
        #hud {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            border-left: 2px solid #00f2ff; padding-left: 15px; background: rgba(0,0,0,0.3);
        }
        .metric { margin-bottom: 5px; font-size: 10px; letter-spacing: 1px; }
        .value { color: #fff; font-weight: bold; }

        /* Glitch Title */
        .title-container {
            position: absolute; top: 20px; right: 40px; text-align: right;
        }
        .glitch {
            font-size: 24px; font-weight: 900; position: relative; color: #fff;
            text-shadow: 0.05em 0 0 rgba(255,0,0,0.75), -0.025em -0.05em 0 rgba(0,255,0,0.75), 0.025em 0.05em 0 rgba(0,0,255,0.75);
            animation: glitch 500ms infinite;
        }
        @keyframes glitch {
            0% { text-shadow: 1px 0 0 red, -1px 0 0 blue; }
            14% { text-shadow: 1px 0 0 red, -1px 0 0 blue; }
            15% { text-shadow: -3px -2px 0 red, 3px 2px 0 blue; }
            49% { text-shadow: -3px -2px 0 red, 3px 2px 0 blue; }
            50% { text-shadow: 3px 2px 0 red, -3px -2px 0 blue; }
            99% { text-shadow: 3px 2px 0 red, -3px -2px 0 blue; }
            100% { text-shadow: -1px 0 0 red, 1px 0 0 blue; }
        }

        #instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            font-size: 12px; border: 1px solid #00f2ff; padding: 10px 20px;
            cursor: pointer; transition: all 0.3s; background: rgba(0, 242, 255, 0.1);
            pointer-events: auto;
        }
        #instructions:hover { background: #00f2ff; color: #000; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="metric">SYSTEM: <span class="value">QUANTUM_CORE_V3</span></div>
        <div class="metric">PARTICLES: <span class="value">100,000</span></div>
        <div class="metric">FPS: <span id="fps" class="value">60</span></div>
        <div class="metric">SHAPE_ID: <span id="shapeId" class="value">0</span></div>
        <div class="metric">TIME: <span id="time" class="value">0.00</span></div>
        <div class="metric">DPR: <span id="dpr" class="value">1.0</span></div>
    </div>

    <div class="title-container">
        <div class="glitch">MORPH_ENGINE_V1</div>
        <div style="font-size: 10px; opacity: 0.7;">NEURAL TOPOLOGY VISUALIZER</div>
    </div>

    <div id="instructions">INITIATE MORPH SEQUENCE [CLICK]</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { gsap } from 'https://cdn.skypack.dev/gsap';

        // --- GLSL SHADERS ---
        const vertexShader = `
            uniform float uTime;
            uniform float uMorphProgress;
            uniform int uTargetShape; // 0: Sphere, 1: Torus, 2: Noise, 3: Box
            uniform float uNoiseIntensity;

            attribute vec3 positionSphere;
            attribute vec3 positionTorus;
            attribute vec3 positionNoise;
            attribute vec3 positionBox;

            varying vec3 vColor;
            varying float vNoise;

            // Simplex 3D Noise (simplified for performance)
            vec4 permute(vec4 x){ return mod(((x*34.0)+1.0)*x, 289.0); }
            vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v){ 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + 1.0 * C.xxx;
                vec3 x2 = x0 - i2 + 2.0 * C.xxx;
                vec3 x3 = x0 - D.yyy;
                i = mod(i, 289.0); 
                vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 1.0/7.0;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z *ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                // Morph logic
                vec3 target;
                if(uTargetShape == 0) target = positionSphere;
                else if(uTargetShape == 1) target = positionTorus;
                else if(uTargetShape == 2) target = positionNoise;
                else target = positionBox;

                // Interpolate from current position to target
                vec3 pos = mix(position, target, uMorphProgress);
                
                // Simplex Noise Jitter
                float noise = snoise(pos * 0.5 + uTime * 0.2);
                pos += normalize(pos) * noise * uNoiseIntensity;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = (1.5 / -mvPosition.z) * 500.0;
                gl_Position = projectionMatrix * mvPosition;

                // Color based on position and noise
                vColor = mix(vec3(0.0, 0.95, 1.0), vec3(1.0), noise * 0.5 + 0.5);
                vNoise = noise;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vNoise;

            void main() {
                // Circular particles
                float dist = distance(gl_PointCoord, vec2(0.5));
                if (dist > 0.5) discard;
                
                float alpha = smoothstep(0.5, 0.2, dist);
                gl_FragColor = vec4(vColor, alpha * (0.8 + vNoise * 0.2));
            }
        `;

        // --- ENGINE SETUP ---
        let scene, camera, renderer, composer, particles, material;
        let currentShape = 0;
        const count = 100000;
        const mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050505);
            document.body.appendChild(renderer.domElement);

            // Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- GEOMETRY ---
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const spherePos = new Float32Array(count * 3);
            const torusPos = new Float32Array(count * 3);
            const noisePos = new Float32Array(count * 3);
            const boxPos = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Initial (Random)
                positions[i3] = (Math.random() - 0.5) * 10;
                positions[i3+1] = (Math.random() - 0.5) * 10;
                positions[i3+2] = (Math.random() - 0.5) * 10;

                // Sphere
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 2.5;
                spherePos[i3] = r * Math.sin(phi) * Math.cos(theta);
                spherePos[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                spherePos[i3+2] = r * Math.cos(phi);

                // Torus
                const tr = 2.0; // main radius
                const tt = 0.8; // tube radius
                const ta = Math.random() * Math.PI * 2;
                const tb = Math.random() * Math.PI * 2;
                torusPos[i3] = (tr + tt * Math.cos(tb)) * Math.cos(ta);
                torusPos[i3+1] = (tr + tt * Math.cos(tb)) * Math.sin(ta);
                torusPos[i3+2] = tt * Math.sin(tb);

                // Noise Cloud
                noisePos[i3] = (Math.random() - 0.5) * 6;
                noisePos[i3+1] = (Math.random() - 0.5) * 6;
                noisePos[i3+2] = (Math.random() - 0.5) * 6;

                // Box
                boxPos[i3] = (Math.random() - 0.5) * 4;
                boxPos[i3+1] = (Math.random() - 0.5) * 4;
                boxPos[i3+2] = (Math.random() - 0.5) * 4;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('positionSphere', new THREE.BufferAttribute(spherePos, 3));
            geo.setAttribute('positionTorus', new THREE.BufferAttribute(torusPos, 3));
            geo.setAttribute('positionNoise', new THREE.BufferAttribute(noisePos, 3));
            geo.setAttribute('positionBox', new THREE.BufferAttribute(boxPos, 3));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uMorphProgress: { value: 0 },
                    uTargetShape: { value: 0 },
                    uNoiseIntensity: { value: 0.1 }
                },
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geo, material);
            scene.add(particles);

            // Interaction
            window.addEventListener('click', morphToNext);
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('resize', onWindowResize);
            document.getElementById('dpr').innerText = window.devicePixelRatio.toFixed(1);
        }

        function morphToNext() {
            currentShape = (currentShape + 1) % 4;
            document.getElementById('shapeId').innerText = currentShape;

            const tl = gsap.timeline();

            // Camera Action: Zoom In/Out Pulse
            tl.to(camera.position, { z: 2, duration: 0.4, ease: "power2.in" });
            tl.to(camera.position, { z: 5, duration: 1.2, ease: "elastic.out(1, 0.3)" });

            // Morph Progress
            tl.to(material.uniforms.uMorphProgress, { 
                value: 1, 
                duration: 1.5, 
                ease: "expo.inOut",
                onComplete: () => {
                    // Update the 'current' position attribute to the new shape to prepare for next morph
                    const attrName = ['positionSphere', 'positionTorus', 'positionNoise', 'positionBox'][currentShape];
                    particles.geometry.attributes.position.array.set(particles.geometry.attributes[attrName].array);
                    particles.geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorphProgress.value = 0;
                    material.uniforms.uTargetShape.value = (currentShape + 1) % 4;
                }
            }, 0);

            // Noise Pulse
            tl.to(material.uniforms.uNoiseIntensity, { value: 2.5, duration: 0.4 }, 0);
            tl.to(material.uniforms.uNoiseIntensity, { value: 0.1, duration: 1.0, ease: "power2.out" }, 0.4);

            // Bloom Pulse
            const bloom = composer.passes[1];
            tl.to(bloom, { strength: 4.0, duration: 0.2 }, 0);
            tl.to(bloom, { strength: 1.2, duration: 1.0 }, 0.2);

            // Screen Shake (simulated with camera rotation)
            tl.to(camera.rotation, { x: 0.1, y: 0.1, duration: 0.05, repeat: 5, yoyo: true }, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            material.uniforms.uTime.value = time;

            // Subtle Camera Rotation based on mouse
            particles.rotation.y += 0.002;
            scene.rotation.x += (mouse.y * 0.2 - scene.rotation.x) * 0.05;
            scene.rotation.y += (mouse.x * 0.2 - scene.rotation.y) * 0.05;

            // HUD Update
            document.getElementById('time').innerText = time.toFixed(2);
            document.getElementById('fps').innerText = Math.round(1000 / (performance.now() - (animate.lastTime || 0)));
            animate.lastTime = performance.now();

            composer.render();
        }
    </script>
</body>
</html>
